library(caTools)
split <- sample.split(final$C, SplitRatio = 0.75)
dresstrain <- subset(final, split == TRUE)
dresstest <- subset(final, split == FALSE)
## Let's check the count of unique value in the target variable
as.data.frame(table(dresstrain$C))
final$C <- as.factor(final$C)
ggplot(final, aes(x = "", y = C, fill = C)) +
geom_bar(width = 1, stat = "identity", color = "white") +
geom_text(aes(y = lab.ypos, label = C), color = "white")+
coord_polar("y", start = 0)+
ggpubr::fill_palette("jco")+
theme_void()
set.seed(1029)
## Remove rows that do not have target variable values
final <- train[!(is.na(train$C)),]
final$C <- factor(final$C)
library(caTools)
split <- sample.split(final$C, SplitRatio = 0.75)
dresstrain <- subset(final, split == TRUE)
dresstest <- subset(final, split == FALSE)
## Let's check the count of unique value in the target variable
as.data.frame(table(dresstrain$C))
final$C <- as.factor(final$C)
ggplot(final, aes(x = c, y = counts)) +
geom_bar(fill = "#0073C2FF", stat = "identity") +
geom_text(aes(label = counts), vjust = -0.3) +
theme_pubclean()
set.seed(1029)
## Remove rows that do not have target variable values
final <- train[!(is.na(train$C)),]
final$C <- factor(final$C)
library(caTools)
split <- sample.split(final$C, SplitRatio = 0.75)
dresstrain <- subset(final, split == TRUE)
dresstest <- subset(final, split == FALSE)
## Let's check the count of unique value in the target variable
as.data.frame(table(dresstrain$C))
final$C <- as.factor(final$C)
ggplot(final, aes(x = c, y = counts)) +
geom_bar(fill = "#0073C2FF", stat = "identity") +
geom_text(aes(label = counts), vjust = -0.3)
library(dplyr)
set.seed(1029)
## Remove rows that do not have target variable values
final <- train[!(is.na(train$C)),]
final$C <- factor(final$C)
library(caTools)
split <- sample.split(final$C, SplitRatio = 0.75)
dresstrain <- subset(final, split == TRUE)
dresstest <- subset(final, split == FALSE)
## Let's check the count of unique value in the target variable
as.data.frame(table(dresstrain$C))
final$C <- as.factor(final$C)
ggplot(final, aes(x = c, y = counts)) +
geom_bar(fill = "#0073C2FF", stat = "identity") +
geom_text(aes(label = counts), vjust = -0.3)
library(ggplot2)
library(ggpubr)
set.seed(1029)
## Remove rows that do not have target variable values
final <- train[!(is.na(train$C)),]
final$C <- factor(final$C)
library(caTools)
split <- sample.split(final$C, SplitRatio = 0.75)
dresstrain <- subset(final, split == TRUE)
dresstest <- subset(final, split == FALSE)
## Let's check the count of unique value in the target variable
as.data.frame(table(dresstrain$C))
final$C <- as.factor(final$C)
ggplot(final, aes(x = c, y = counts)) +
geom_bar(fill = "#0073C2FF", stat = "identity") +
geom_text(aes(label = counts), vjust = -0.3)
library(ggplot2)
library(ggpubr)
set.seed(1029)
## Remove rows that do not have target variable values
final <- train[!(is.na(train$C)),]
final$C <- factor(final$C)
library(caTools)
split <- sample.split(final$C, SplitRatio = 0.75)
dresstrain <- subset(final, split == TRUE)
dresstest <- subset(final, split == FALSE)
## Let's check the count of unique value in the target variable
as.data.frame(table(dresstrain$C))
final$C <- as.factor(final$C)
ggplot(final, aes(x = c, y = counts), inherit.aes = FALSE) +
geom_bar(fill = "#0073C2FF", stat = "identity") +
geom_text(aes(label = counts), vjust = -0.3)
library(ggplot2)
library(ggpubr)
set.seed(1029)
## Remove rows that do not have target variable values
final <- train[!(is.na(train$C)),]
final$C <- factor(final$C)
library(caTools)
split <- sample.split(final$C, SplitRatio = 0.75)
dresstrain <- subset(final, split == TRUE)
dresstest <- subset(final, split == FALSE)
## Let's check the count of unique value in the target variable
as.data.frame(table(dresstrain$C))
final$C <- as.factor(final$C)
ggplot(final, aes(C)) + geom_bar()
library(ggplot2)
library(ggpubr)
set.seed(1029)
## Remove rows that do not have target variable values
final <- train[!(is.na(train$C)),]
final$C <- factor(final$C)
library(caTools)
split <- sample.split(final$C, SplitRatio = 0.75)
dresstrain <- subset(final, split == TRUE)
dresstest <- subset(final, split == FALSE)
## Let's check the count of unique value in the target variable
as.data.frame(table(dresstrain$C))
ggplot(final, aes(C)) + geom_bar()
library(ggplot2)
library(ggpubr)
set.seed(1029)
## Remove rows that do not have target variable values
final <- train[!(is.na(train$C)),]
final$C <- factor(final$C)
library(caTools)
split <- sample.split(final$C, SplitRatio = 0.75)
dresstrain <- subset(final, split == TRUE)
dresstest <- subset(final, split == FALSE)
## Let's check the count of unique value in the target variable
as.data.frame(table(dresstrain$C))
final$C <- as.factor(final$C)
ggplot(final, aes(C)) + geom_bar()
library(ggplot2)
ggplot(final, aes(C)) + geom_bar()
head(train)
library(mice)
# carga de datos disponibles directamente en el paquete mice
datos <- train
# se obtiene el patron de aparicion de datos perdidos
patron <- mice::md.pattern(x=datos)
# se muestra el patron
print(patron)
# determinacion del numero de instancias completas e incompletas
completas <- mice::ncc(datos)
incompletas <- mice::nic(datos)
# Este paquete puede usarse para imputar valores perdidos en
# variables de todo tipo
library(mice)
library(lattice)
# se usa el conjunto airquality
datos <- train
# se determina el numero de instancias sin datos perdidos y con datos
# perdidos. A observar la comodidad de uso de las funciones ncc e nic
completos <- mice::ncc(datos)
incompletos <- mice::nic(datos)
cat("Datos completos: ",completos, " e incompletos: ",incompletos,"\n")
# se realiza la imputacion
imputados <- mice::mice(datos, m=5, meth="pmm")
# dispone de algunos metodos que imputan siempre a un unico
# valor, como por ejemplo "mean"
imputadosMean <- mice::mice(datos, m=1, meth="mean")
# pmm es el metodo por defecto. Puedes verse todos los metodos
# disponibles de la siguiente forma
methods(mice)
# se completa el conjunto de datos con las imputaciones
datosImputados <- mice::complete(imputados)
# se determina el numero de instancias sin datos perdidos y con datos
# perdidos en la parte ya limpia
completos <- mice::ncc(datosImputados)
incompletos <- mice::nic(datosImputados)
cat("Datos completos: ",completos, " e incompletos: ",incompletos,"\n")
# se muestra la imputacion para Ozone
imputados$imp$Ozone
# Se muestra un grafico para comprobar la distribucion de Ozone en los
# datos imputados en relacion a otras variables. Los puntos en azul
# representan datos observados y datos en rojo representan imputaciones
lattice::xyplot(imputados,Ozone ~ Solar.R,pch=18,cex=1)
# Este paquete puede usarse para imputar valores perdidos en
# variables de todo tipo
library(mice)
library(lattice)
# se usa el conjunto airquality
datos <- train
# se determina el numero de instancias sin datos perdidos y con datos
# perdidos. A observar la comodidad de uso de las funciones ncc e nic
completos <- mice::ncc(datos)
incompletos <- mice::nic(datos)
cat("Datos completos: ",completos, " e incompletos: ",incompletos,"\n")
# se realiza la imputacion
imputados <- mice::mice(datos, m=5, meth="pmm")
# dispone de algunos metodos que imputan siempre a un unico
# valor, como por ejemplo "mean"
imputadosMean <- mice::mice(datos, m=1, meth="mean")
# pmm es el metodo por defecto. Puedes verse todos los metodos
# disponibles de la siguiente forma
methods(mice)
# se completa el conjunto de datos con las imputaciones
datosImputados <- mice::complete(imputados)
# se determina el numero de instancias sin datos perdidos y con datos
# perdidos en la parte ya limpia
completos <- mice::ncc(datosImputados)
incompletos <- mice::nic(datosImputados)
cat("Datos completos: ",completos, " e incompletos: ",incompletos,"\n")
# Se muestran las densidades de los datos imputados respecto de los
# observados
lattice::densityplot(imputados)
# Este paquete puede usarse para imputar valores perdidos en
# variables de todo tipo
library(mice)
library(lattice)
# se usa el conjunto airquality
datos <- train
# se determina el numero de instancias sin datos perdidos y con datos
# perdidos. A observar la comodidad de uso de las funciones ncc e nic
completos <- mice::ncc(datos)
incompletos <- mice::nic(datos)
cat("Datos completos: ",completos, " e incompletos: ",incompletos,"\n")
# se realiza la imputacion
imputados <- mice::mice(datos, m=5, meth="pmm")
# dispone de algunos metodos que imputan siempre a un unico
# valor, como por ejemplo "mean"
imputadosMean <- mice::mice(datos, m=1, meth="mean")
# pmm es el metodo por defecto. Puedes verse todos los metodos
# disponibles de la siguiente forma
methods(mice)
# se completa el conjunto de datos con las imputaciones
datosImputados <- mice::complete(imputados)
# se determina el numero de instancias sin datos perdidos y con datos
# perdidos en la parte ya limpia
completos <- mice::ncc(datosImputados)
incompletos <- mice::nic(datosImputados)
cat("Datos completos: ",completos, " e incompletos: ",incompletos,"\n")
methods(mice)
?data.frame
?as.data.frame
#Lectura de datos
original.dataset <- readData()
original.dataset <- scale(original.dataset)
#Lectura de datos
original.dataset <- readData()
original.dataset[,-1] <- scale(original.dataset[,-1])
original.dataset[,-1]
original.dataset <- readData()
#Lectura de datos
original.dataset <- readData()
train <- original.dataset$train
test <- original.dataset$test
#train$C <- as.factor(train$C)
original.dataset[,-1]
original.dataset
original.dataset$train[,-1]
#Lectura de datos
original.dataset <- readData()
original.dataset$train[,-1] <- scale(original.dataset$train[,-1])
original.dataset$test[,-1] <- scale(original.dataset$test[,-1])
train <- original.dataset$train
test <- original.dataset$test
#train$C <- as.factor(train$C)
head(train)
library(VIM)
library(finalfit)
aggr_plot <- aggr(train, numbers=TRUE, sortVars=TRUE, labels=names(train), cex.axis=.7, gap=3, ylab=c("Histogram of missing data Train","Pattern"), prop = T)
train %>% missing_plot()
library(parallel)
system.time(res1 <- apply(train, 1, function(x) sum(is.na(x))) / ncol(train) * 100)
cores <- detectCores()
cluster <- makeCluster(cores-2)
system.time(res2 <- parRapply(cluster, train, function(x) sum(is.na(x)))/ncol(train)*100)
names(res2) <- NULL
stopCluster(cluster)
mal <- (res1 > 5)
filtrados <- train[!mal,]
cat("Instancias archivo original: ",nrow(train)," instancias en filtrado: ",nrow(filtrados),"\n")
#writeData(filtrados, path = "datosFiltrados/", "datosFiltrados")
# Este paquete puede usarse para imputar valores perdidos en
# variables de todo tipo
library(mice)
library(lattice)
# se usa el conjunto airquality
datos <- train
# se determina el numero de instancias sin datos perdidos y con datos
# perdidos. A observar la comodidad de uso de las funciones ncc e nic
completos <- mice::ncc(datos)
incompletos <- mice::nic(datos)
# se realiza la imputacion
imputados <- mice::mice(datos, m=5, meth="pmm")
# se completa el conjunto de datos con las imputaciones
datosImputados <- mice::complete(imputados)
# se determina el numero de instancias sin datos perdidos y con datos
# perdidos en la parte ya limpia
completos <- mice::ncc(datosImputados)
incompletos <- mice::nic(datosImputados)
# Este paquete puede usarse para imputar valores perdidos en
# variables de todo tipo
library(mice)
library(lattice)
# se usa el conjunto airquality
datos <- train
# se determina el numero de instancias sin datos perdidos y con datos
# perdidos. A observar la comodidad de uso de las funciones ncc e nic
completos <- mice::ncc(datos)
incompletos <- mice::nic(datos)
cat("Datos completos: ",completos, " e incompletos: ",incompletos,"\n")
# se realiza la imputacion
imputados <- mice::mice(datos, m=5, meth="pmm")
# se completa el conjunto de datos con las imputaciones
datosImputados <- mice::complete(imputados)
# se determina el numero de instancias sin datos perdidos y con datos
# perdidos en la parte ya limpia
completos <- mice::ncc(datosImputados)
incompletos <- mice::nic(datosImputados)
cat("Datos completos: ",completos, " e incompletos: ",incompletos,"\n")
#Lectura de datos
original.dataset <- readData()
#original.dataset$train[,-1] <- scale(original.dataset$train[,-1])
#original.dataset$test[,-1] <- scale(original.dataset$test[,-1])
train <- original.dataset$train
test <- original.dataset$test
#train$C <- as.factor(train$C)
head(train)
library(VIM)
library(finalfit)
aggr_plot <- aggr(train, numbers=TRUE, sortVars=TRUE, labels=names(train), cex.axis=.7, gap=3, ylab=c("Histogram of missing data Train","Pattern"), prop = T)
train %>% missing_plot()
library(parallel)
system.time(res1 <- apply(train, 1, function(x) sum(is.na(x))) / ncol(train) * 100)
cores <- detectCores()
cluster <- makeCluster(cores-2)
system.time(res2 <- parRapply(cluster, train, function(x) sum(is.na(x)))/ncol(train)*100)
names(res2) <- NULL
stopCluster(cluster)
mal <- (res1 > 5)
filtrados <- train[!mal,]
cat("Instancias archivo original: ",nrow(train)," instancias en filtrado: ",nrow(filtrados),"\n")
#writeData(filtrados, path = "datosFiltrados/", "datosFiltrados")
library(GGally)
## Create data frame indicating missingness by 1
x <- as.data.frame(abs(is.na(train)))
## Select columns with some (but not all) missing values
y <- x[,sapply(x, sd) > 0]
## Create a correlation matrix: Variables missing together have high correlation
cor(y)
cor(train, y, use = "pairwise.complete.obs")
ggcorr(train, method = c("pairwise.complete.obs", "pearson"))
library(ggplot2)
ggplot(final, aes(C)) + geom_bar()
# d i s p o n i b l e s de l a s i g u i e n t e forma
24 methods( mice )
methods( mice )
# Este paquete puede usarse para imputar valores perdidos en
# variables de todo tipo
library(mice)
library(lattice)
data.imputed <- l
# Este paquete puede usarse para imputar valores perdidos en
# variables de todo tipo
library(mice)
library(lattice)
data.imputed <- list()
# se usa el conjunto airquality
datos <- train
# se determina el numero de instancias sin datos perdidos y con datos
# perdidos. A observar la comodidad de uso de las funciones ncc e nic
completos <- mice::ncc(datos)
incompletos <- mice::nic(datos)
cat("Datos completos: ",completos, " e incompletos: ",incompletos,"\n")
# se realiza la imputacion
m <- 5
imputados.pmm <- mice::mice(datos, m=m, meth="pmm")
imputados.rf <- mice::mice(datos, m=m, meth="rf")
# Este paquete puede usarse para imputar valores perdidos en
# variables de todo tipo
library(mice)
library(lattice)
require(robCompositions)
require(mice)
data.imputed <- list()
# se usa el conjunto airquality
datos <- train
# se determina el numero de instancias sin datos perdidos y con datos
# perdidos. A observar la comodidad de uso de las funciones ncc e nic
completos <- mice::ncc(datos)
incompletos <- mice::nic(datos)
cat("Datos completos: ",completos, " e incompletos: ",incompletos,"\n")
# se realiza la imputacion
m <- 5
imputados.pmm <- mice::mice(datos, m=m, meth="pmm")
imputados.rf <- mice::mice(datos, m=m, meth="rf")
imputados.mean <- mice::mice(datos, m=m, meth="mean")
imputados.norm <- mice::mice(datos, m=m, meth="norm")
data.imputed[["pmm"]] <- mice::complete(imputados.pmm)
data.imputed[["rf"]] <- mice::complete(imputados.rf)
data.imputed[["mean"]] <- mice::complete(imputados.mean)
data.imputed[["norm"]] <- mice::complete(imputados.norm)
data.imputed[["knn"]] <- robCompositions::impKNNa(datos, primitive=TRUE)
imputados.mean <- mice::mice(datos, m=m, meth="mean") #Impute by Average
data.imputed[["mean"]] <- mice::complete(imputados.mean)
writeData(data.imputed[["mean"], path = "datosFiltrados/", "imputedMean")
# Definimos el path de donde estemos trabajando.
setwd(dirname(getActiveDocumentContext()$path))
# Librerias propias
for (file in list.files("preprocess")) {
source(paste("preprocess/", file, collapse = NULL, sep = ""))
}
imputados.mean <- mice::mice(datos, m=m, meth="mean") #Impute by Average
data.imputed[["mean"]] <- mice::complete(imputados.mean)
writeData(data.imputed[["mean"]], path = "datosFiltrados/", "imputedMean")
imputados.norm <- mice::mice(datos, m=m, meth="norm") #Impute by Average
data.imputed[["norm"]] <- mice::complete(imputados.norm)
writeData(data.imputed[["nrom"]], path = "datosFiltrados/", "imputedNrom")
data.imputed[["knn"]] <- robCompositions::impKNNa(datos, primitive=TRUE) #Impute by Predictive Model
writeData(data.imputed[["knn"]], path = "datosFiltrados/", "imputedKnn")
data.imputed[["knn"]]
robCompositions::impKNNa(datos, primitive=TRUE)
# Este paquete puede usarse para imputar valores perdidos en
# variables de todo tipo
library(mice)
library(lattice)
require(robCompositions)
require(mice)
data.imputed <- list()
# se usa el conjunto airquality
datos <- train
# se determina el numero de instancias sin datos perdidos y con datos
# perdidos. A observar la comodidad de uso de las funciones ncc e nic
completos <- mice::ncc(datos)
incompletos <- mice::nic(datos)
cat("Datos completos: ",completos, " e incompletos: ",incompletos,"\n")
# se realiza la imputacion
m <- 5 #Impute by Average
imputados.pmm <- mice::mice(datos, m=m, meth="pmm")
data.imputed[["pmm"]] <- mice::complete(imputados.pmm)
writeData(data.imputed[["pmm"]], path = "datosFiltrados/", "imputedPmm")
imputados.rf <- mice::mice(datos, m=m, meth="rf", ntree = 3)
data.imputed[["rf"]] <- mice::complete(imputados.rf)
writeData(data.imputed[["rf"]], path = "datosFiltrados/", "imputedRf")
imputados.mean <- mice::mice(datos, m=m, meth="mean") #Impute by Average
data.imputed[["mean"]] <- mice::complete(imputados.mean)
writeData(data.imputed[["mean"]], path = "datosFiltrados/", "imputedMean")
imputados.norm <- mice::mice(datos, m=m, meth="norm") #Impute by Average
data.imputed[["norm"]] <- mice::complete(imputados.norm)
writeData(data.imputed[["nrom"]], path = "datosFiltrados/", "imputedNrom")
data.imputed[["knn"]] <- robCompositions::impKNNa(datos, primitive=TRUE) #Impute by Predictive Model
# Definimos el path de donde estemos trabajando.
setwd(dirname(getActiveDocumentContext()$path))
# Librerias propias
for (file in list.files("preprocess")) {
source(paste("preprocess/", file, collapse = NULL, sep = ""))
}
# Este paquete puede usarse para imputar valores perdidos en
# variables de todo tipo
library(mice)
library(lattice)
require(robCompositions)
require(mice)
data.imputed <- list()
# se usa el conjunto airquality
datos <- train
# se determina el numero de instancias sin datos perdidos y con datos
# perdidos. A observar la comodidad de uso de las funciones ncc e nic
completos <- mice::ncc(datos)
incompletos <- mice::nic(datos)
cat("Datos completos: ",completos, " e incompletos: ",incompletos,"\n")
# se realiza la imputacion
m <- 5 #Impute by Average
imputados.pmm <- mice::mice(datos, m=m, meth="pmm")
data.imputed[["pmm"]] <- mice::complete(imputados.pmm)
writeData(data.imputed[["pmm"]], path = "datosFiltrados/", "imputedPmm")
imputados.rf <- mice::mice(datos, m=m, meth="rf", ntree = 3)
data.imputed[["rf"]] <- mice::complete(imputados.rf)
writeData(data.imputed[["rf"]], path = "datosFiltrados/", "imputedRf")
# Definimos el path de donde estemos trabajando.
setwd(dirname(getActiveDocumentContext()$path))
# Librerias propias
for (file in list.files("preprocess")) {
source(paste("preprocess/", file, collapse = NULL, sep = ""))
}
data.imputed[["knnCustom"]] <- imputacionKnnTotal(datos)
writeData(data.imputed[["knnCustom"]], path = "datosFiltrados/", "imputedRf")
getwd()
setwd("/home/jaime/Master/DataMining/decisionTree")
writeData(data.imputed[["knnCustom"]], path = "datosFiltrados/", "imputedRf")
writeData(data.imputed[["knnCustom"]], path = "datosFiltrados/", "imputedKnnCustom")
# Este paquete puede usarse para imputar valores perdidos en
# variables de todo tipo
library(mice)
library(lattice)
require(robCompositions)
require(mice)
data.imputed <- list()
# se usa el conjunto airquality
datos <- train
# se determina el numero de instancias sin datos perdidos y con datos
# perdidos. A observar la comodidad de uso de las funciones ncc e nic
completos <- mice::ncc(datos)
incompletos <- mice::nic(datos)
cat("Datos completos: ",completos, " e incompletos: ",incompletos,"\n")
# se realiza la imputacion
m <- 5 #Impute by Average
imputados.pmm <- mice::mice(datos, m=m, meth="pmm")
data.imputed[["pmm"]] <- mice::complete(imputados.pmm)
writeData(data.imputed[["pmm"]], path = "datosFiltrados/", "imputedPmm")
imputados.rf <- mice::mice(datos, m=m, meth="rf", ntree = 3)
data.imputed[["rf"]] <- mice::complete(imputados.rf)
writeData(data.imputed[["rf"]], path = "datosFiltrados/", "imputedRf")
imputados.mean <- mice::mice(datos, m=m, meth="mean") #Impute by Average
data.imputed[["mean"]] <- mice::complete(imputados.mean)
writeData(data.imputed[["mean"]], path = "datosFiltrados/", "imputedMean")
imputados.norm <- mice::mice(datos, m=m, meth="norm") #Impute by Average
data.imputed[["norm"]] <- mice::complete(imputados.norm)
writeData(data.imputed[["nrom"]], path = "datosFiltrados/", "imputedNrom")
data.imputed[["knn"]] <- robCompositions::impKNNa(datos, primitive=TRUE) #Impute by Predictive Model
getwd()
data.imputed[["knn"]] <- robCompositions::impKNNa(datos, primitive=TRUE) #Impute by Predictive Model
